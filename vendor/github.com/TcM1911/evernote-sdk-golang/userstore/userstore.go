// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package userstore

import (
	"bytes"
	"fmt"

	"github.com/TcM1911/evernote-sdk-golang/errors"
	"github.com/TcM1911/evernote-sdk-golang/types"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var _ = types.GoUnusedProtection__
var _ = errors.GoUnusedProtection__

type UserStore interface { //Service:  UserStore
	//<p>
	//The UserStore service is primarily used by EDAM clients to establish
	//authentication via username and password over a trusted connection (e.g.
	//SSL).  A client's first call to this interface should be checkVersion() to
	//ensure that the client's software is up to date.
	//</p>
	//All calls which require an authenticationToken may throw an
	//EDAMUserException for the following reasons:
	// <ul>
	//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
	//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
	//  <li> DATA_REQUIRED "authenticationToken" - token is empty
	//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
	//</ul>

	// This should be the first call made by a client to the EDAM service.  It
	// tells the service what protocol version is used by the client.  The
	// service will then return true if the client is capable of talking to
	// the service, and false if the client's protocol version is incompatible
	// with the service, so the client must upgrade.  If a client receives a
	// false value, it should report the incompatibility to the user and not
	// continue with any more EDAM requests (UserStore or NoteStore).
	//
	// @param clientName
	//   This string provides some information about the client for
	//   tracking/logging on the service.  It should provide information about
	//   the client's software and platform. The structure should be:
	//   application/version; platform/version; [ device/version ]
	//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
	//
	// @param edamVersionMajor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MAJOR
	//   constant for the client.
	//
	// @param edamVersionMinor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MINOR
	//   constant for the client.
	//
	// Parameters:
	//  - ClientName
	//  - EdamVersionMajor
	//  - EdamVersionMinor
	CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error)
	// This provides bootstrap information to the client. Various bootstrap
	// profiles and settings may be used by the client to configure itself.
	//
	// @param locale
	//   The client's current locale, expressed in language[_country]
	//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
	//   language and country codes.
	//
	// @return
	//   The bootstrap information suitable for this client.
	//
	// Parameters:
	//  - Locale
	GetBootstrapInfo(locale string) (r *BootstrapInfo, err error)
	// This is used to check a username and password in order to create a
	// short-lived authentication session that can be used for further actions.
	//
	// This function is only available to Evernote's internal applications.
	// Third party applications must authenticate using OAuth as
	// described at
	// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
	//
	// @param username
	//   The username (not numeric user ID) for the account to
	//   authenticate against.  This function will also accept the user's
	//   registered email address in this parameter.
	//
	// @param password
	//   The plaintext password to check against the account.  Since
	//   this is not protected by the EDAM protocol, this information must be
	//   provided over a protected transport (e.g. SSL).
	//
	// @param consumerKey
	//   The "consumer key" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param consumerSecret
	//   The "consumer secret" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param supportsTwoFactor
	//   Whether the calling application supports two-factor authentication. If this
	//   parameter is false, this method will fail with the error code INVALID_AUTH and the
	//   parameter "password" when called for a user who has enabled two-factor
	//   authentication.
	//
	// @return
	//   <p>The result of the authentication.  If the authentication was successful,
	//   the AuthenticationResult.user field will be set with the full information
	//   about the User.</p>
	//   <p>If the user has two-factor authentication enabled,
	//   AuthenticationResult.secondFactorRequired will be set and
	//   AuthenticationResult.authenticationToken will contain a short-lived token
	//   that may only be used to complete the two-factor authentication process by calling
	//   UserStore.completeTwoFactorAuthentication.</p>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	//   <li> DATA_REQUIRED "password" - password is empty
	//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
	//   <li> INVALID_AUTH "username" - username not found
	//   <li> INVALID_AUTH "password" - password did not match
	//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
	//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	// </ul>
	//
	// Parameters:
	//  - Username
	//  - Password
	//  - ConsumerKey
	//  - ConsumerSecret
	//  - SupportsTwoFactor
	Authenticate(username string, password string, consumerKey string, consumerSecret string, supportsTwoFactor bool) (r *AuthenticationResult_, err error)
	// This is used to check a username and password in order to create a
	// long-lived authentication token that can be used for further actions.
	//
	// This function is not available to most third party applications,
	// which typically authenticate using OAuth as
	// described at
	// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
	// If you believe that your application requires permission to authenticate
	// using username and password instead of OAuth, please contact Evernote
	// developer support by visiting
	// <a href="http://dev.evernote.com">dev.evernote.com</a>.
	//
	// @param username
	//   The username or registered email address of the account to
	//   authenticate against.
	//
	// @param password
	//   The plaintext password to check against the account.  Since
	//   this is not protected by the EDAM protocol, this information must be
	//   provided over a protected transport (i.e. SSL).
	//
	// @param consumerKey
	//   The "consumer key" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param consumerSecret
	//   The "consumer secret" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param deviceIdentifier
	//   An optional string, no more than 32 characters in length, that uniquely identifies
	//   the device from which the authentication is being performed. This string allows
	//   the service to return the same authentication token when a given application
	//   requests authentication repeatedly from the same device. This may happen when the
	//   user logs out of an application and then logs back in, or when the application is
	//   uninstalled and later reinstalled. If no reliable device identifier can be created,
	//   this value should be omitted. If set, the device identifier must be between
	//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
	//   EDAM_DEVICE_ID_REGEX.
	//
	// @param deviceDescription
	//   A description of the device from which the authentication is being performed.
	//   This field is displayed to the user in a list of authorized applications to
	//   allow them to distinguish between multiple tokens issued to the same client
	//   application on different devices. For example, the Evernote iOS client on
	//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
	//   "Bob's iPad". The device description must be between 1 and
	//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
	//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
	//
	// @param supportsTwoFactor
	//   Whether the calling application supports two-factor authentication. If this
	//   parameter is false, this method will fail with the error code INVALID_AUTH and the
	//   parameter "password" when called for a user who has enabled two-factor
	//   authentication.
	//
	// @return
	//   <p>The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by
	//   calling application's API key.</p>
	//   <p>If the user has two-factor authentication enabled,
	//   AuthenticationResult.secondFactorRequired will be set and
	//   AuthenticationResult.authenticationToken will contain a short-lived token
	//   that may only be used to complete the two-factor authentication process by calling
	//   UserStore.completeTwoFactorAuthentication.</p>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	//   <li> DATA_REQUIRED "password" - password is empty
	//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
	//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
	//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
	//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
	//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
	//   <li> INVALID_AUTH "username" - username not found
	//   <li> INVALID_AUTH "password" - password did not match
	//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
	//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	// </ul>
	//
	// Parameters:
	//  - Username
	//  - Password
	//  - ConsumerKey
	//  - ConsumerSecret
	//  - DeviceIdentifier
	//  - DeviceDescription
	//  - SupportsTwoFactor
	AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult_, err error)
	// Complete the authentication process when a second factor is required. This
	// call is made after a successful call to authenticate or authenticateLongSession
	// when the authenticating user has enabled two-factor authentication.
	//
	// @param authenticationToken An authentication token returned by a previous
	//   call to UserStore.authenticate or UserStore.authenticateLongSession that
	//   could not be completed in a single call because a second factor was required.
	//
	// @param oneTimeCode The one time code entered by the user. This value is delivered
	//   out-of-band, typically via SMS or an authenticator application.
	//
	// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
	//
	// @param deviceDescription See the corresponding parameter in authenticateLongSession.
	//
	// @return
	//   The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by the
	//   calling application's API key. If the initial authentication call was made to
	//   authenticateLongSession, the AuthenticationResult will contain a long-lived
	//   authentication token.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
	//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
	//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
	//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
	//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
	//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
	//      two-factor authentication.</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - OneTimeCode
	//  - DeviceIdentifier
	//  - DeviceDescription
	CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult_, err error)
	// Revoke an existing long lived authentication token. This can be used to
	// revoke OAuth tokens or tokens created by calling authenticateLongSession,
	// and allows a user to effectively log out of Evernote from the perspective
	// of the application that holds the token. The authentication token that is
	// passed is immediately revoked and may not be used to call any authenticated
	// EDAM function.
	//
	// @param authenticationToken the authentication token to revoke.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
	//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
	//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
	//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
	//     is already revoked.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	RevokeLongSession(authenticationToken string) (err error)
	// This is used to take an existing authentication token that grants access
	// to an individual user account (returned from 'authenticate',
	// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
	// authentication token that may be used to access business notebooks if the user
	// is a member of an Evernote Business account.
	//
	// The resulting authentication token may be used to make NoteStore API calls
	// against the business using the NoteStore URL returned in the result.
	//
	// @param authenticationToken
	//   The authentication token for the user. This may not be a shared authentication
	//   token (returned by NoteStore.authenticateToSharedNotebook or
	//   NoteStore.authenticateToSharedNote) or a business authentication token.
	//
	// @return
	//   The result of the authentication, with the token granting access to the
	//   business in the result's 'authenticationToken' field. The URL that must
	//   be used to access the business account NoteStore will be returned in the
	//   result's 'noteStoreUrl' field.  The 'User' field will
	//   not be set in the result.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
	//        is a shared or business authentication token. </li>
	//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
	//        authentication token is not currently a member of a business. </li>
	//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
	//        member of is not currently in an active status. </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult_, err error)
	// This is used to take an existing authentication token (returned from
	// 'authenticate') and exchange it for a newer token which will not expire
	// as soon.  This must be invoked before the previous token expires.
	//
	// This function is only availabe to Evernote's internal applications.
	//
	// @param authenticationToken
	//   The previous authentication token from the authenticate() result.
	//
	// @return
	//   The result of the authentication, with the new token in
	//   the result's 'authenticationToken' field.  The 'User' field will
	//   not be set in the result.
	//
	// Parameters:
	//  - AuthenticationToken
	RefreshAuthentication(authenticationToken string) (r *AuthenticationResult_, err error)
	// Returns the User corresponding to the provided authentication token,
	// or throws an exception if this token is not valid.
	// The level of detail provided in the returned User structure depends on
	// the access level granted by the token, so a web service client may receive
	// fewer fields than an integrated desktop client.
	//
	// Parameters:
	//  - AuthenticationToken
	GetUser(authenticationToken string) (r *types.User, err error)
	// Asks the UserStore about the publicly available location information for
	// a particular username.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	// </ul>
	//
	// Parameters:
	//  - Username
	GetPublicUserInfo(username string) (r *PublicUserInfo, err error)
	// Returns information regarding a user's Premium account corresponding to the
	// provided authentication token, or throws an exception if this token is not
	// valid.
	//
	// Parameters:
	//  - AuthenticationToken
	GetPremiumInfo(authenticationToken string) (r *types.PremiumInfo, err error)
	// Returns the URL that should be used to talk to the NoteStore for the
	// account represented by the provided authenticationToken.
	// This method isn't needed by most clients, who can retrieve the correct
	// NoteStore URL from the AuthenticationResult returned from the authenticate
	// or refreshAuthentication calls. This method is typically only needed
	// to look up the correct URL for a long-lived session token (e.g. for an
	// OAuth web service).
	//
	// Parameters:
	//  - AuthenticationToken
	GetNoteStoreUrl(authenticationToken string) (r string, err error)
}

//Service:  UserStore
//<p>
//The UserStore service is primarily used by EDAM clients to establish
//authentication via username and password over a trusted connection (e.g.
//SSL).  A client's first call to this interface should be checkVersion() to
//ensure that the client's software is up to date.
//</p>
//All calls which require an authenticationToken may throw an
//EDAMUserException for the following reasons:
// <ul>
//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
//  <li> DATA_REQUIRED "authenticationToken" - token is empty
//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
//</ul>
type UserStoreClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewUserStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewUserStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// This should be the first call made by a client to the EDAM service.  It
// tells the service what protocol version is used by the client.  The
// service will then return true if the client is capable of talking to
// the service, and false if the client's protocol version is incompatible
// with the service, so the client must upgrade.  If a client receives a
// false value, it should report the incompatibility to the user and not
// continue with any more EDAM requests (UserStore or NoteStore).
//
// @param clientName
//   This string provides some information about the client for
//   tracking/logging on the service.  It should provide information about
//   the client's software and platform. The structure should be:
//   application/version; platform/version; [ device/version ]
//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
//
// @param edamVersionMajor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MAJOR
//   constant for the client.
//
// @param edamVersionMinor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MINOR
//   constant for the client.
//
// Parameters:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
func (p *UserStoreClient) CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error) {
	if err = p.sendCheckVersion(clientName, edamVersionMajor, edamVersionMinor); err != nil {
		return
	}
	return p.recvCheckVersion()
}

func (p *UserStoreClient) sendCheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkVersion", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreCheckVersionArgs{
		ClientName:       clientName,
		EdamVersionMajor: edamVersionMajor,
		EdamVersionMinor: edamVersionMinor,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvCheckVersion() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "checkVersion" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "checkVersion failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkVersion failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error1 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error2 error
		error2, err = error1.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error2
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "checkVersion failed: invalid message type")
		return
	}
	result := UserStoreCheckVersionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// This provides bootstrap information to the client. Various bootstrap
// profiles and settings may be used by the client to configure itself.
//
// @param locale
//   The client's current locale, expressed in language[_country]
//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
//   language and country codes.
//
// @return
//   The bootstrap information suitable for this client.
//
// Parameters:
//  - Locale
func (p *UserStoreClient) GetBootstrapInfo(locale string) (r *BootstrapInfo, err error) {
	if err = p.sendGetBootstrapInfo(locale); err != nil {
		return
	}
	return p.recvGetBootstrapInfo()
}

func (p *UserStoreClient) sendGetBootstrapInfo(locale string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getBootstrapInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetBootstrapInfoArgs{
		Locale: locale,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetBootstrapInfo() (value *BootstrapInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getBootstrapInfo" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getBootstrapInfo failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getBootstrapInfo failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error3 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error4 error
		error4, err = error3.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error4
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getBootstrapInfo failed: invalid message type")
		return
	}
	result := UserStoreGetBootstrapInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// This is used to check a username and password in order to create a
// short-lived authentication session that can be used for further actions.
//
// This function is only available to Evernote's internal applications.
// Third party applications must authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
//
// @param username
//   The username (not numeric user ID) for the account to
//   authenticate against.  This function will also accept the user's
//   registered email address in this parameter.
//
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (e.g. SSL).
//
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
//
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
//
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
//
// @return
//   <p>The result of the authentication.  If the authentication was successful,
//   the AuthenticationResult.user field will be set with the full information
//   about the User.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
// </ul>
//
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - SupportsTwoFactor
func (p *UserStoreClient) Authenticate(username string, password string, consumerKey string, consumerSecret string, supportsTwoFactor bool) (r *AuthenticationResult_, err error) {
	if err = p.sendAuthenticate(username, password, consumerKey, consumerSecret, supportsTwoFactor); err != nil {
		return
	}
	return p.recvAuthenticate()
}

func (p *UserStoreClient) sendAuthenticate(username string, password string, consumerKey string, consumerSecret string, supportsTwoFactor bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("authenticate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreAuthenticateArgs{
		Username:          username,
		Password:          password,
		ConsumerKey:       consumerKey,
		ConsumerSecret:    consumerSecret,
		SupportsTwoFactor: supportsTwoFactor,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvAuthenticate() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "authenticate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "authenticate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "authenticate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error6 error
		error6, err = error5.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error6
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "authenticate failed: invalid message type")
		return
	}
	result := UserStoreAuthenticateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// This is used to check a username and password in order to create a
// long-lived authentication token that can be used for further actions.
//
// This function is not available to most third party applications,
// which typically authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
// If you believe that your application requires permission to authenticate
// using username and password instead of OAuth, please contact Evernote
// developer support by visiting
// <a href="http://dev.evernote.com">dev.evernote.com</a>.
//
// @param username
//   The username or registered email address of the account to
//   authenticate against.
//
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (i.e. SSL).
//
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
//
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
//
// @param deviceIdentifier
//   An optional string, no more than 32 characters in length, that uniquely identifies
//   the device from which the authentication is being performed. This string allows
//   the service to return the same authentication token when a given application
//   requests authentication repeatedly from the same device. This may happen when the
//   user logs out of an application and then logs back in, or when the application is
//   uninstalled and later reinstalled. If no reliable device identifier can be created,
//   this value should be omitted. If set, the device identifier must be between
//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
//   EDAM_DEVICE_ID_REGEX.
//
// @param deviceDescription
//   A description of the device from which the authentication is being performed.
//   This field is displayed to the user in a list of authorized applications to
//   allow them to distinguish between multiple tokens issued to the same client
//   application on different devices. For example, the Evernote iOS client on
//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
//   "Bob's iPad". The device description must be between 1 and
//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
//
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
//
// @return
//   <p>The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by
//   calling application's API key.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
// </ul>
//
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
func (p *UserStoreClient) AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult_, err error) {
	if err = p.sendAuthenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor); err != nil {
		return
	}
	return p.recvAuthenticateLongSession()
}

func (p *UserStoreClient) sendAuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("authenticateLongSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreAuthenticateLongSessionArgs{
		Username:          username,
		Password:          password,
		ConsumerKey:       consumerKey,
		ConsumerSecret:    consumerSecret,
		DeviceIdentifier:  deviceIdentifier,
		DeviceDescription: deviceDescription,
		SupportsTwoFactor: supportsTwoFactor,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvAuthenticateLongSession() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "authenticateLongSession" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "authenticateLongSession failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "authenticateLongSession failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "authenticateLongSession failed: invalid message type")
		return
	}
	result := UserStoreAuthenticateLongSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Complete the authentication process when a second factor is required. This
// call is made after a successful call to authenticate or authenticateLongSession
// when the authenticating user has enabled two-factor authentication.
//
// @param authenticationToken An authentication token returned by a previous
//   call to UserStore.authenticate or UserStore.authenticateLongSession that
//   could not be completed in a single call because a second factor was required.
//
// @param oneTimeCode The one time code entered by the user. This value is delivered
//   out-of-band, typically via SMS or an authenticator application.
//
// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
//
// @param deviceDescription See the corresponding parameter in authenticateLongSession.
//
// @return
//   The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by the
//   calling application's API key. If the initial authentication call was made to
//   authenticateLongSession, the AuthenticationResult will contain a long-lived
//   authentication token.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
//      two-factor authentication.</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
func (p *UserStoreClient) CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult_, err error) {
	if err = p.sendCompleteTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription); err != nil {
		return
	}
	return p.recvCompleteTwoFactorAuthentication()
}

func (p *UserStoreClient) sendCompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreCompleteTwoFactorAuthenticationArgs{
		AuthenticationToken: authenticationToken,
		OneTimeCode:         oneTimeCode,
		DeviceIdentifier:    deviceIdentifier,
		DeviceDescription:   deviceDescription,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvCompleteTwoFactorAuthentication() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "completeTwoFactorAuthentication" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "completeTwoFactorAuthentication failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "completeTwoFactorAuthentication failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error9 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error10 error
		error10, err = error9.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error10
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "completeTwoFactorAuthentication failed: invalid message type")
		return
	}
	result := UserStoreCompleteTwoFactorAuthenticationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Revoke an existing long lived authentication token. This can be used to
// revoke OAuth tokens or tokens created by calling authenticateLongSession,
// and allows a user to effectively log out of Evernote from the perspective
// of the application that holds the token. The authentication token that is
// passed is immediately revoked and may not be used to call any authenticated
// EDAM function.
//
// @param authenticationToken the authentication token to revoke.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
//     is already revoked.
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RevokeLongSession(authenticationToken string) (err error) {
	if err = p.sendRevokeLongSession(authenticationToken); err != nil {
		return
	}
	return p.recvRevokeLongSession()
}

func (p *UserStoreClient) sendRevokeLongSession(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("revokeLongSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreRevokeLongSessionArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvRevokeLongSession() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "revokeLongSession" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "revokeLongSession failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "revokeLongSession failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "revokeLongSession failed: invalid message type")
		return
	}
	result := UserStoreRevokeLongSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	return
}

// This is used to take an existing authentication token that grants access
// to an individual user account (returned from 'authenticate',
// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
// authentication token that may be used to access business notebooks if the user
// is a member of an Evernote Business account.
//
// The resulting authentication token may be used to make NoteStore API calls
// against the business using the NoteStore URL returned in the result.
//
// @param authenticationToken
//   The authentication token for the user. This may not be a shared authentication
//   token (returned by NoteStore.authenticateToSharedNotebook or
//   NoteStore.authenticateToSharedNote) or a business authentication token.
//
// @return
//   The result of the authentication, with the token granting access to the
//   business in the result's 'authenticationToken' field. The URL that must
//   be used to access the business account NoteStore will be returned in the
//   result's 'noteStoreUrl' field.  The 'User' field will
//   not be set in the result.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
//        is a shared or business authentication token. </li>
//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
//        authentication token is not currently a member of a business. </li>
//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
//        member of is not currently in an active status. </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult_, err error) {
	if err = p.sendAuthenticateToBusiness(authenticationToken); err != nil {
		return
	}
	return p.recvAuthenticateToBusiness()
}

func (p *UserStoreClient) sendAuthenticateToBusiness(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("authenticateToBusiness", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreAuthenticateToBusinessArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvAuthenticateToBusiness() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "authenticateToBusiness" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "authenticateToBusiness failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "authenticateToBusiness failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error13 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error14 error
		error14, err = error13.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error14
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "authenticateToBusiness failed: invalid message type")
		return
	}
	result := UserStoreAuthenticateToBusinessResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// This is used to take an existing authentication token (returned from
// 'authenticate') and exchange it for a newer token which will not expire
// as soon.  This must be invoked before the previous token expires.
//
// This function is only availabe to Evernote's internal applications.
//
// @param authenticationToken
//   The previous authentication token from the authenticate() result.
//
// @return
//   The result of the authentication, with the new token in
//   the result's 'authenticationToken' field.  The 'User' field will
//   not be set in the result.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RefreshAuthentication(authenticationToken string) (r *AuthenticationResult_, err error) {
	if err = p.sendRefreshAuthentication(authenticationToken); err != nil {
		return
	}
	return p.recvRefreshAuthentication()
}

func (p *UserStoreClient) sendRefreshAuthentication(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("refreshAuthentication", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreRefreshAuthenticationArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvRefreshAuthentication() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "refreshAuthentication" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "refreshAuthentication failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "refreshAuthentication failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "refreshAuthentication failed: invalid message type")
		return
	}
	result := UserStoreRefreshAuthenticationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Returns the User corresponding to the provided authentication token,
// or throws an exception if this token is not valid.
// The level of detail provided in the returned User structure depends on
// the access level granted by the token, so a web service client may receive
// fewer fields than an integrated desktop client.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUser(authenticationToken string) (r *types.User, err error) {
	if err = p.sendGetUser(authenticationToken); err != nil {
		return
	}
	return p.recvGetUser()
}

func (p *UserStoreClient) sendGetUser(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getUser", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetUserArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetUser() (value *types.User, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getUser" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getUser failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getUser failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error17 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error18 error
		error18, err = error17.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error18
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getUser failed: invalid message type")
		return
	}
	result := UserStoreGetUserResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Asks the UserStore about the publicly available location information for
// a particular username.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
// </ul>
//
// Parameters:
//  - Username
func (p *UserStoreClient) GetPublicUserInfo(username string) (r *PublicUserInfo, err error) {
	if err = p.sendGetPublicUserInfo(username); err != nil {
		return
	}
	return p.recvGetPublicUserInfo()
}

func (p *UserStoreClient) sendGetPublicUserInfo(username string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getPublicUserInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetPublicUserInfoArgs{
		Username: username,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetPublicUserInfo() (value *PublicUserInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getPublicUserInfo" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getPublicUserInfo failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getPublicUserInfo failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getPublicUserInfo failed: invalid message type")
		return
	}
	result := UserStoreGetPublicUserInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.NotFoundException != nil {
		err = result.NotFoundException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	} else if result.UserException != nil {
		err = result.UserException
		return
	}
	value = result.GetSuccess()
	return
}

// Returns information regarding a user's Premium account corresponding to the
// provided authentication token, or throws an exception if this token is not
// valid.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetPremiumInfo(authenticationToken string) (r *types.PremiumInfo, err error) {
	if err = p.sendGetPremiumInfo(authenticationToken); err != nil {
		return
	}
	return p.recvGetPremiumInfo()
}

func (p *UserStoreClient) sendGetPremiumInfo(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getPremiumInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetPremiumInfoArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetPremiumInfo() (value *types.PremiumInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getPremiumInfo" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getPremiumInfo failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getPremiumInfo failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error21 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error22 error
		error22, err = error21.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error22
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getPremiumInfo failed: invalid message type")
		return
	}
	result := UserStoreGetPremiumInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Returns the URL that should be used to talk to the NoteStore for the
// account represented by the provided authenticationToken.
// This method isn't needed by most clients, who can retrieve the correct
// NoteStore URL from the AuthenticationResult returned from the authenticate
// or refreshAuthentication calls. This method is typically only needed
// to look up the correct URL for a long-lived session token (e.g. for an
// OAuth web service).
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetNoteStoreUrl(authenticationToken string) (r string, err error) {
	if err = p.sendGetNoteStoreUrl(authenticationToken); err != nil {
		return
	}
	return p.recvGetNoteStoreUrl()
}

func (p *UserStoreClient) sendGetNoteStoreUrl(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getNoteStoreUrl", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetNoteStoreUrlArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetNoteStoreUrl() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getNoteStoreUrl" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getNoteStoreUrl failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getNoteStoreUrl failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getNoteStoreUrl failed: invalid message type")
		return
	}
	result := UserStoreGetNoteStoreUrlResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

type UserStoreProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      UserStore
}

func (p *UserStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *UserStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *UserStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewUserStoreProcessor(handler UserStore) *UserStoreProcessor {

	self25 := &UserStoreProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self25.processorMap["checkVersion"] = &userStoreProcessorCheckVersion{handler: handler}
	self25.processorMap["getBootstrapInfo"] = &userStoreProcessorGetBootstrapInfo{handler: handler}
	self25.processorMap["authenticate"] = &userStoreProcessorAuthenticate{handler: handler}
	self25.processorMap["authenticateLongSession"] = &userStoreProcessorAuthenticateLongSession{handler: handler}
	self25.processorMap["completeTwoFactorAuthentication"] = &userStoreProcessorCompleteTwoFactorAuthentication{handler: handler}
	self25.processorMap["revokeLongSession"] = &userStoreProcessorRevokeLongSession{handler: handler}
	self25.processorMap["authenticateToBusiness"] = &userStoreProcessorAuthenticateToBusiness{handler: handler}
	self25.processorMap["refreshAuthentication"] = &userStoreProcessorRefreshAuthentication{handler: handler}
	self25.processorMap["getUser"] = &userStoreProcessorGetUser{handler: handler}
	self25.processorMap["getPublicUserInfo"] = &userStoreProcessorGetPublicUserInfo{handler: handler}
	self25.processorMap["getPremiumInfo"] = &userStoreProcessorGetPremiumInfo{handler: handler}
	self25.processorMap["getNoteStoreUrl"] = &userStoreProcessorGetNoteStoreUrl{handler: handler}
	return self25
}

func (p *UserStoreProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x26 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x26.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x26

}

type userStoreProcessorCheckVersion struct {
	handler UserStore
}

func (p *userStoreProcessorCheckVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreCheckVersionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreCheckVersionResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckVersion(args.ClientName, args.EdamVersionMajor, args.EdamVersionMinor); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkVersion: "+err2.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkVersion", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetBootstrapInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetBootstrapInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetBootstrapInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetBootstrapInfoResult{}
	var retval *BootstrapInfo
	var err2 error
	if retval, err2 = p.handler.GetBootstrapInfo(args.Locale); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getBootstrapInfo: "+err2.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getBootstrapInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticate struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreAuthenticateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreAuthenticateResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.Authenticate(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.SupportsTwoFactor); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticate: "+err2.Error())
			oprot.WriteMessageBegin("authenticate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("authenticate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreAuthenticateLongSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreAuthenticateLongSessionResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.AuthenticateLongSession(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.DeviceIdentifier, args.DeviceDescription, args.SupportsTwoFactor); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateLongSession: "+err2.Error())
			oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("authenticateLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorCompleteTwoFactorAuthentication struct {
	handler UserStore
}

func (p *userStoreProcessorCompleteTwoFactorAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreCompleteTwoFactorAuthenticationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreCompleteTwoFactorAuthenticationResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.CompleteTwoFactorAuthentication(args.AuthenticationToken, args.OneTimeCode, args.DeviceIdentifier, args.DeviceDescription); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing completeTwoFactorAuthentication: "+err2.Error())
			oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRevokeLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorRevokeLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreRevokeLongSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreRevokeLongSessionResult{}
	var err2 error
	if err2 = p.handler.RevokeLongSession(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing revokeLongSession: "+err2.Error())
			oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("revokeLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateToBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateToBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreAuthenticateToBusinessArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreAuthenticateToBusinessResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.AuthenticateToBusiness(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToBusiness: "+err2.Error())
			oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("authenticateToBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRefreshAuthentication struct {
	handler UserStore
}

func (p *userStoreProcessorRefreshAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreRefreshAuthenticationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("refreshAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreRefreshAuthenticationResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.RefreshAuthentication(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing refreshAuthentication: "+err2.Error())
			oprot.WriteMessageBegin("refreshAuthentication", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("refreshAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetUser struct {
	handler UserStore
}

func (p *userStoreProcessorGetUser) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetUserArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetUserResult{}
	var retval *types.User
	var err2 error
	if retval, err2 = p.handler.GetUser(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUser: "+err2.Error())
			oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getUser", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetPublicUserInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetPublicUserInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetPublicUserInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetPublicUserInfoResult{}
	var retval *PublicUserInfo
	var err2 error
	if retval, err2 = p.handler.GetPublicUserInfo(args.Username); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMNotFoundException:
			result.NotFoundException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		case *errors.EDAMUserException:
			result.UserException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicUserInfo: "+err2.Error())
			oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getPublicUserInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetPremiumInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetPremiumInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetPremiumInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPremiumInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetPremiumInfoResult{}
	var retval *types.PremiumInfo
	var err2 error
	if retval, err2 = p.handler.GetPremiumInfo(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPremiumInfo: "+err2.Error())
			oprot.WriteMessageBegin("getPremiumInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getPremiumInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetNoteStoreUrl struct {
	handler UserStore
}

func (p *userStoreProcessorGetNoteStoreUrl) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetNoteStoreUrlArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getNoteStoreUrl", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetNoteStoreUrlResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.GetNoteStoreUrl(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteStoreUrl: "+err2.Error())
			oprot.WriteMessageBegin("getNoteStoreUrl", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getNoteStoreUrl", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
type UserStoreCheckVersionArgs struct {
	ClientName       string `thrift:"clientName,1" json:"clientName"`
	EdamVersionMajor int16  `thrift:"edamVersionMajor,2" json:"edamVersionMajor"`
	EdamVersionMinor int16  `thrift:"edamVersionMinor,3" json:"edamVersionMinor"`
}

func NewUserStoreCheckVersionArgs() *UserStoreCheckVersionArgs {
	return &UserStoreCheckVersionArgs{
		EdamVersionMajor: 1,

		EdamVersionMinor: 25,
	}
}

func (p *UserStoreCheckVersionArgs) GetClientName() string {
	return p.ClientName
}

func (p *UserStoreCheckVersionArgs) GetEdamVersionMajor() int16 {
	return p.EdamVersionMajor
}

func (p *UserStoreCheckVersionArgs) GetEdamVersionMinor() int16 {
	return p.EdamVersionMinor
}
func (p *UserStoreCheckVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClientName = v
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EdamVersionMajor = v
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.EdamVersionMinor = v
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("clientName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clientName: ", p), err)
	}
	if err := oprot.WriteString(string(p.ClientName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clientName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clientName: ", p), err)
	}
	return err
}

func (p *UserStoreCheckVersionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMajor", thrift.I16, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:edamVersionMajor: ", p), err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMajor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.edamVersionMajor (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:edamVersionMajor: ", p), err)
	}
	return err
}

func (p *UserStoreCheckVersionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMinor", thrift.I16, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:edamVersionMinor: ", p), err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMinor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.edamVersionMinor (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:edamVersionMinor: ", p), err)
	}
	return err
}

func (p *UserStoreCheckVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCheckVersionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type UserStoreCheckVersionResult struct {
	Success *bool `thrift:"success,0" json:"success,omitempty"`
}

func NewUserStoreCheckVersionResult() *UserStoreCheckVersionResult {
	return &UserStoreCheckVersionResult{}
}

var UserStoreCheckVersionResult_Success_DEFAULT bool

func (p *UserStoreCheckVersionResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return UserStoreCheckVersionResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *UserStoreCheckVersionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreCheckVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCheckVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *UserStoreCheckVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCheckVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCheckVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCheckVersionResult(%+v)", *p)
}

// Attributes:
//  - Locale
type UserStoreGetBootstrapInfoArgs struct {
	Locale string `thrift:"locale,1" json:"locale"`
}

func NewUserStoreGetBootstrapInfoArgs() *UserStoreGetBootstrapInfoArgs {
	return &UserStoreGetBootstrapInfoArgs{}
}

func (p *UserStoreGetBootstrapInfoArgs) GetLocale() string {
	return p.Locale
}
func (p *UserStoreGetBootstrapInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Locale = v
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("locale", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:locale: ", p), err)
	}
	if err := oprot.WriteString(string(p.Locale)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.locale (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:locale: ", p), err)
	}
	return err
}

func (p *UserStoreGetBootstrapInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetBootstrapInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
type UserStoreGetBootstrapInfoResult struct {
	Success *BootstrapInfo `thrift:"success,0" json:"success,omitempty"`
}

func NewUserStoreGetBootstrapInfoResult() *UserStoreGetBootstrapInfoResult {
	return &UserStoreGetBootstrapInfoResult{}
}

var UserStoreGetBootstrapInfoResult_Success_DEFAULT *BootstrapInfo

func (p *UserStoreGetBootstrapInfoResult) GetSuccess() *BootstrapInfo {
	if !p.IsSetSuccess() {
		return UserStoreGetBootstrapInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *UserStoreGetBootstrapInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetBootstrapInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &BootstrapInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetBootstrapInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetBootstrapInfoResult(%+v)", *p)
}

// Attributes:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - SupportsTwoFactor
type UserStoreAuthenticateArgs struct {
	Username          string `thrift:"username,1" json:"username"`
	Password          string `thrift:"password,2" json:"password"`
	ConsumerKey       string `thrift:"consumerKey,3" json:"consumerKey"`
	ConsumerSecret    string `thrift:"consumerSecret,4" json:"consumerSecret"`
	SupportsTwoFactor bool   `thrift:"supportsTwoFactor,5" json:"supportsTwoFactor"`
}

func NewUserStoreAuthenticateArgs() *UserStoreAuthenticateArgs {
	return &UserStoreAuthenticateArgs{}
}

func (p *UserStoreAuthenticateArgs) GetUsername() string {
	return p.Username
}

func (p *UserStoreAuthenticateArgs) GetPassword() string {
	return p.Password
}

func (p *UserStoreAuthenticateArgs) GetConsumerKey() string {
	return p.ConsumerKey
}

func (p *UserStoreAuthenticateArgs) GetConsumerSecret() string {
	return p.ConsumerSecret
}

func (p *UserStoreAuthenticateArgs) GetSupportsTwoFactor() bool {
	return p.SupportsTwoFactor
}
func (p *UserStoreAuthenticateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Username = v
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Password = v
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ConsumerKey = v
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ConsumerSecret = v
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.SupportsTwoFactor = v
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:password: ", p), err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.password (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:password: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerKey", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consumerKey: ", p), err)
	}
	if err := oprot.WriteString(string(p.ConsumerKey)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consumerKey (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consumerKey: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerSecret", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consumerSecret: ", p), err)
	}
	if err := oprot.WriteString(string(p.ConsumerSecret)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consumerSecret (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consumerSecret: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("supportsTwoFactor", thrift.BOOL, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:supportsTwoFactor: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.SupportsTwoFactor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.supportsTwoFactor (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:supportsTwoFactor: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateResult() *UserStoreAuthenticateResult {
	return &UserStoreAuthenticateResult{}
}

var UserStoreAuthenticateResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreAuthenticateResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreAuthenticateResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreAuthenticateResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreAuthenticateResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreAuthenticateResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreAuthenticateResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreAuthenticateResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreAuthenticateResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreAuthenticateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreAuthenticateResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreAuthenticateResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreAuthenticateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreAuthenticateResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateResult(%+v)", *p)
}

// Attributes:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
type UserStoreAuthenticateLongSessionArgs struct {
	Username          string `thrift:"username,1" json:"username"`
	Password          string `thrift:"password,2" json:"password"`
	ConsumerKey       string `thrift:"consumerKey,3" json:"consumerKey"`
	ConsumerSecret    string `thrift:"consumerSecret,4" json:"consumerSecret"`
	DeviceIdentifier  string `thrift:"deviceIdentifier,5" json:"deviceIdentifier"`
	DeviceDescription string `thrift:"deviceDescription,6" json:"deviceDescription"`
	SupportsTwoFactor bool   `thrift:"supportsTwoFactor,7" json:"supportsTwoFactor"`
}

func NewUserStoreAuthenticateLongSessionArgs() *UserStoreAuthenticateLongSessionArgs {
	return &UserStoreAuthenticateLongSessionArgs{}
}

func (p *UserStoreAuthenticateLongSessionArgs) GetUsername() string {
	return p.Username
}

func (p *UserStoreAuthenticateLongSessionArgs) GetPassword() string {
	return p.Password
}

func (p *UserStoreAuthenticateLongSessionArgs) GetConsumerKey() string {
	return p.ConsumerKey
}

func (p *UserStoreAuthenticateLongSessionArgs) GetConsumerSecret() string {
	return p.ConsumerSecret
}

func (p *UserStoreAuthenticateLongSessionArgs) GetDeviceIdentifier() string {
	return p.DeviceIdentifier
}

func (p *UserStoreAuthenticateLongSessionArgs) GetDeviceDescription() string {
	return p.DeviceDescription
}

func (p *UserStoreAuthenticateLongSessionArgs) GetSupportsTwoFactor() bool {
	return p.SupportsTwoFactor
}
func (p *UserStoreAuthenticateLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.readField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Username = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Password = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ConsumerKey = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ConsumerSecret = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.SupportsTwoFactor = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:password: ", p), err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.password (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:password: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerKey", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consumerKey: ", p), err)
	}
	if err := oprot.WriteString(string(p.ConsumerKey)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consumerKey (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consumerKey: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerSecret", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consumerSecret: ", p), err)
	}
	if err := oprot.WriteString(string(p.ConsumerSecret)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consumerSecret (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consumerSecret: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:deviceIdentifier: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceIdentifier (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:deviceIdentifier: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:deviceDescription: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceDescription (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:deviceDescription: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("supportsTwoFactor", thrift.BOOL, 7); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:supportsTwoFactor: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.SupportsTwoFactor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.supportsTwoFactor (7) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 7:supportsTwoFactor: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateLongSessionArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateLongSessionResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateLongSessionResult() *UserStoreAuthenticateLongSessionResult {
	return &UserStoreAuthenticateLongSessionResult{}
}

var UserStoreAuthenticateLongSessionResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreAuthenticateLongSessionResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreAuthenticateLongSessionResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreAuthenticateLongSessionResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreAuthenticateLongSessionResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreAuthenticateLongSessionResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreAuthenticateLongSessionResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreAuthenticateLongSessionResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreAuthenticateLongSessionResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreAuthenticateLongSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreAuthenticateLongSessionResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreAuthenticateLongSessionResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreAuthenticateLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateLongSessionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
type UserStoreCompleteTwoFactorAuthenticationArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
	OneTimeCode         string `thrift:"oneTimeCode,2" json:"oneTimeCode"`
	DeviceIdentifier    string `thrift:"deviceIdentifier,3" json:"deviceIdentifier"`
	DeviceDescription   string `thrift:"deviceDescription,4" json:"deviceDescription"`
}

func NewUserStoreCompleteTwoFactorAuthenticationArgs() *UserStoreCompleteTwoFactorAuthenticationArgs {
	return &UserStoreCompleteTwoFactorAuthenticationArgs{}
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetOneTimeCode() string {
	return p.OneTimeCode
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetDeviceIdentifier() string {
	return p.DeviceIdentifier
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetDeviceDescription() string {
	return p.DeviceDescription
}
func (p *UserStoreCompleteTwoFactorAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.OneTimeCode = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oneTimeCode", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:oneTimeCode: ", p), err)
	}
	if err := oprot.WriteString(string(p.OneTimeCode)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.oneTimeCode (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:oneTimeCode: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:deviceIdentifier: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceIdentifier (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:deviceIdentifier: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:deviceDescription: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceDescription (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:deviceDescription: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCompleteTwoFactorAuthenticationArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreCompleteTwoFactorAuthenticationResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreCompleteTwoFactorAuthenticationResult() *UserStoreCompleteTwoFactorAuthenticationResult {
	return &UserStoreCompleteTwoFactorAuthenticationResult{}
}

var UserStoreCompleteTwoFactorAuthenticationResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreCompleteTwoFactorAuthenticationResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreCompleteTwoFactorAuthenticationResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreCompleteTwoFactorAuthenticationResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreCompleteTwoFactorAuthenticationResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreCompleteTwoFactorAuthenticationResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCompleteTwoFactorAuthenticationResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreRevokeLongSessionArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreRevokeLongSessionArgs() *UserStoreRevokeLongSessionArgs {
	return &UserStoreRevokeLongSessionArgs{}
}

func (p *UserStoreRevokeLongSessionArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreRevokeLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreRevokeLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreRevokeLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRevokeLongSessionArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
type UserStoreRevokeLongSessionResult struct {
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreRevokeLongSessionResult() *UserStoreRevokeLongSessionResult {
	return &UserStoreRevokeLongSessionResult{}
}

var UserStoreRevokeLongSessionResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreRevokeLongSessionResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreRevokeLongSessionResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreRevokeLongSessionResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreRevokeLongSessionResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreRevokeLongSessionResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreRevokeLongSessionResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreRevokeLongSessionResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreRevokeLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRevokeLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRevokeLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRevokeLongSessionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreAuthenticateToBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreAuthenticateToBusinessArgs() *UserStoreAuthenticateToBusinessArgs {
	return &UserStoreAuthenticateToBusinessArgs{}
}

func (p *UserStoreAuthenticateToBusinessArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreAuthenticateToBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateToBusinessArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateToBusinessResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateToBusinessResult() *UserStoreAuthenticateToBusinessResult {
	return &UserStoreAuthenticateToBusinessResult{}
}

var UserStoreAuthenticateToBusinessResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreAuthenticateToBusinessResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreAuthenticateToBusinessResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreAuthenticateToBusinessResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreAuthenticateToBusinessResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreAuthenticateToBusinessResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreAuthenticateToBusinessResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreAuthenticateToBusinessResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreAuthenticateToBusinessResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreAuthenticateToBusinessResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreAuthenticateToBusinessResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreAuthenticateToBusinessResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreAuthenticateToBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateToBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreRefreshAuthenticationArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreRefreshAuthenticationArgs() *UserStoreRefreshAuthenticationArgs {
	return &UserStoreRefreshAuthenticationArgs{}
}

func (p *UserStoreRefreshAuthenticationArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreRefreshAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refreshAuthentication_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreRefreshAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRefreshAuthenticationArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreRefreshAuthenticationResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreRefreshAuthenticationResult() *UserStoreRefreshAuthenticationResult {
	return &UserStoreRefreshAuthenticationResult{}
}

var UserStoreRefreshAuthenticationResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreRefreshAuthenticationResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreRefreshAuthenticationResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreRefreshAuthenticationResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreRefreshAuthenticationResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreRefreshAuthenticationResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreRefreshAuthenticationResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreRefreshAuthenticationResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreRefreshAuthenticationResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreRefreshAuthenticationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreRefreshAuthenticationResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreRefreshAuthenticationResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreRefreshAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refreshAuthentication_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRefreshAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRefreshAuthenticationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRefreshAuthenticationResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRefreshAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRefreshAuthenticationResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetUserArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreGetUserArgs() *UserStoreGetUserArgs {
	return &UserStoreGetUserArgs{}
}

func (p *UserStoreGetUserArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreGetUserArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetUserArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreGetUserArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetUserArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreGetUserArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetUserArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetUserResult struct {
	Success         *types.User                 `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreGetUserResult() *UserStoreGetUserResult {
	return &UserStoreGetUserResult{}
}

var UserStoreGetUserResult_Success_DEFAULT *types.User

func (p *UserStoreGetUserResult) GetSuccess() *types.User {
	if !p.IsSetSuccess() {
		return UserStoreGetUserResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetUserResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetUserResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetUserResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreGetUserResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetUserResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetUserResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreGetUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetUserResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetUserResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetUserResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &types.User{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetUserResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetUserResult(%+v)", *p)
}

// Attributes:
//  - Username
type UserStoreGetPublicUserInfoArgs struct {
	Username string `thrift:"username,1" json:"username"`
}

func NewUserStoreGetPublicUserInfoArgs() *UserStoreGetPublicUserInfoArgs {
	return &UserStoreGetPublicUserInfoArgs{}
}

func (p *UserStoreGetPublicUserInfoArgs) GetUsername() string {
	return p.Username
}
func (p *UserStoreGetPublicUserInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Username = v
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err)
	}
	return err
}

func (p *UserStoreGetPublicUserInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetPublicUserInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - NotFoundException
//  - SystemException
//  - UserException
type UserStoreGetPublicUserInfoResult struct {
	Success           *PublicUserInfo               `thrift:"success,0" json:"success,omitempty"`
	NotFoundException *errors.EDAMNotFoundException `thrift:"notFoundException,1" json:"notFoundException,omitempty"`
	SystemException   *errors.EDAMSystemException   `thrift:"systemException,2" json:"systemException,omitempty"`
	UserException     *errors.EDAMUserException     `thrift:"userException,3" json:"userException,omitempty"`
}

func NewUserStoreGetPublicUserInfoResult() *UserStoreGetPublicUserInfoResult {
	return &UserStoreGetPublicUserInfoResult{}
}

var UserStoreGetPublicUserInfoResult_Success_DEFAULT *PublicUserInfo

func (p *UserStoreGetPublicUserInfoResult) GetSuccess() *PublicUserInfo {
	if !p.IsSetSuccess() {
		return UserStoreGetPublicUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetPublicUserInfoResult_NotFoundException_DEFAULT *errors.EDAMNotFoundException

func (p *UserStoreGetPublicUserInfoResult) GetNotFoundException() *errors.EDAMNotFoundException {
	if !p.IsSetNotFoundException() {
		return UserStoreGetPublicUserInfoResult_NotFoundException_DEFAULT
	}
	return p.NotFoundException
}

var UserStoreGetPublicUserInfoResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetPublicUserInfoResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetPublicUserInfoResult_SystemException_DEFAULT
	}
	return p.SystemException
}

var UserStoreGetPublicUserInfoResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetPublicUserInfoResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetPublicUserInfoResult_UserException_DEFAULT
	}
	return p.UserException
}
func (p *UserStoreGetPublicUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetNotFoundException() bool {
	return p.NotFoundException != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetPublicUserInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &PublicUserInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField1(iprot thrift.TProtocol) error {
	p.NotFoundException = &errors.EDAMNotFoundException{}
	if err := p.NotFoundException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField3(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetNotFoundException() {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notFoundException: ", p), err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notFoundException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetPublicUserInfoResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetPremiumInfoArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreGetPremiumInfoArgs() *UserStoreGetPremiumInfoArgs {
	return &UserStoreGetPremiumInfoArgs{}
}

func (p *UserStoreGetPremiumInfoArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreGetPremiumInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreGetPremiumInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPremiumInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreGetPremiumInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetPremiumInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetPremiumInfoResult struct {
	Success         *types.PremiumInfo          `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreGetPremiumInfoResult() *UserStoreGetPremiumInfoResult {
	return &UserStoreGetPremiumInfoResult{}
}

var UserStoreGetPremiumInfoResult_Success_DEFAULT *types.PremiumInfo

func (p *UserStoreGetPremiumInfoResult) GetSuccess() *types.PremiumInfo {
	if !p.IsSetSuccess() {
		return UserStoreGetPremiumInfoResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetPremiumInfoResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetPremiumInfoResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetPremiumInfoResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreGetPremiumInfoResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetPremiumInfoResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetPremiumInfoResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreGetPremiumInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetPremiumInfoResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetPremiumInfoResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetPremiumInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &types.PremiumInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPremiumInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetPremiumInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPremiumInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPremiumInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPremiumInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetPremiumInfoResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetNoteStoreUrlArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreGetNoteStoreUrlArgs() *UserStoreGetNoteStoreUrlArgs {
	return &UserStoreGetNoteStoreUrlArgs{}
}

func (p *UserStoreGetNoteStoreUrlArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreGetNoteStoreUrlArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNoteStoreUrl_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreGetNoteStoreUrlArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetNoteStoreUrlArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetNoteStoreUrlResult struct {
	Success         *string                     `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreGetNoteStoreUrlResult() *UserStoreGetNoteStoreUrlResult {
	return &UserStoreGetNoteStoreUrlResult{}
}

var UserStoreGetNoteStoreUrlResult_Success_DEFAULT string

func (p *UserStoreGetNoteStoreUrlResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return UserStoreGetNoteStoreUrlResult_Success_DEFAULT
	}
	return *p.Success
}

var UserStoreGetNoteStoreUrlResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetNoteStoreUrlResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetNoteStoreUrlResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreGetNoteStoreUrlResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetNoteStoreUrlResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetNoteStoreUrlResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreGetNoteStoreUrlResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetNoteStoreUrlResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetNoteStoreUrlResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetNoteStoreUrlResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNoteStoreUrl_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetNoteStoreUrlResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetNoteStoreUrlResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetNoteStoreUrlResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetNoteStoreUrlResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetNoteStoreUrlResult(%+v)", *p)
}
